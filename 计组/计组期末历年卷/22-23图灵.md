## 单选

1. 下面运算中，哪个 OF=1(Overflow), CO=1(Carry Output).
   A. 0x12+0x78
   B. 0x80+0x80
   C. 0x12+0x34
   D. 0x12+0x1F

2. IEEE 单精度下能表示的最大规格化数(normalized) 是多少？
   A.FFFFFFFF B. FFFF7FFF C. 7F7FFFFF D. 忘了

3. 我要把一个大整数 A(32 bit) 加载到 x29 中，如何做？

   A.

   ```
   lui x29, higher_bits
   ori x29, x29, lower_bits
   ```

   B.

   ```
   lui x5, higher_bits
   ld x29, lower_bits(x5)
   ```

   C.

   ```
   lui x5, higher_bits
   ori x5, lower_bits
   ld x29, 0(x5)
   ```

   D.

   ```
   addi x29, x0, higher_bits
   slli x29, x29, 16
   ori x29, x29, lower_bits
   ```

4. 当前 PC 地址 0x30000000, jal 范围
   A. `[1FF00000, 200FFFFF]`
   B. `[1FF00000, 200FFFFE]`
   C. `[1FF80000, 200FFFFE]`
   D. `[1FF00000, 200FFFFF]`

5. 单周期 CPU 中，以下哪些操作是不能在一个时钟周期内完成的
   A. 从内存里读，并写数据
   B. ALU 计算，并写数据到内存
   C. 更新 PC, 并写数据到内存
   D. 从寄存器堆读值，进行 ALU 计算，并写数据到内存。

6. 如果我们采用 a mixed cache 用来取指和读内存，会有什么冒险？
   A. 啥都没有
   B. Data hazard
   C. Control hazard
   D. Structural hazard

7. 提高 cache 的组相联度可以提高(improve)
   A. capacity miss
   B. hit time
   C. conflict miss
   D. compulsory miss

8. 下面的编程指令，有没有 RAW, WAR, WAW 依赖

   ```
   x2
   x1
   x3 具体不记得了
   ```

9. 关于异常的说法，哪个是不正确的
   A. 进入处理程序前要把原因放入 cause register.
   B. 要把当前指令的地址放到 mepc, 以便处理程序执行结束后返回
   C. 要调到 mtvec 的位置
   D. 处理程序执行结束后要 jalr x0, 0(x1)

10. RAID 中，Rundancy 是作用是什么
    A. 提高速度
    B. 忘了
    C. 检验读写正确性
    D. 提高硬盘的是 reliability

## 大题

1. CPI 计算

   200 MHz. 采用 mixed cache. ALU/Logic 35%
   Load 30%
   Store 15%
   Branch 20%

   cache hit rate 98%, 内存读写 100ns. branch 采用 predict-not-taken. 假设跳转在 3rd 阶段决定。
   branch not taken 的比例为 40%, load 后有 50% 的比例会有 load-use hazard. 求 CPI.

2. Pipeline

   (1) LW 指令的 PCSrc ALUSrc MemToReg MemWrite RegWrite
   (2) 插入 nop

   ```
   addi 
   lw sp
   
   lw t1, 0(t1)
   lw t1,
   sw t1, 0(t2)
   ```

   (3) 添加 datapath 以支持 forwarding 解决 RAW 的竞争
   (4) 对于添加了上一问 forwarding 的通路，画出此时 (2) 指令执行的流水线图，并标出数据前递，格式如下
   例：MemWB.ALUOut -> ALU up port

3. 汇编

   (1) 用汇编实现 `int B[k]=A[i-j]` 其中 i,j,k 在 . A, B 在 x10, x11
   (2) 实现（注意 RISC-V calling convention）

   ```
   int sum(int *u, int n) {            // int is 32-bit
       int i, sum = 0;
       for (i = 0; i < n; i++) 
           if (isOk(u[i]))sum += u[i];
       return sum;
   }
   bool isOk(int x) {
       if (x>=0 && x<=100) return true;
       else return false;
   }
   ```

4. 已知 virtual memory address 54 bits，physical memory address 32 bits;
   4KB cache 2路组相连，block size 128B, LRU
   TLB fully associative, 128 entries
   page size 4KB

   （1）求 cache 的 data, index, tag, byte offset bits 以及放在缓存中的 tag/valid bits(NOTE: 包括 VALID bit)
   求页表的 offset, 虚拟页号位，物理页号位. TLB 需要多少个 comparator.

   （2）下面顺序访问(r 代表 read, w 代表 write)
   0w 64r 96w 100r 400r 800r 1000r 16Cw
   求 hit rate, replaced block?
   求从 cache 中写到内存的块?
   （3）根据上边的查询，给出最后cache中的内容（仅需给出valid部分），以如下格式: `<index, tag, data[xx bytes-xx bytes]>`